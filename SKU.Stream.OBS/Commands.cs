// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using ObsWebsocket;
//
//    var commands = Commands.FromJson(jsonString);

namespace SKU.Stream.OBS
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class Commands
    {
        [JsonProperty("events")]
        public Events Events { get; set; }

        [JsonProperty("requests")]
        public Requests Requests { get; set; }
    }

    public partial class Events
    {
        [JsonProperty("scenes")]
        public List<General> Scenes { get; set; }

        [JsonProperty("transitions")]
        public List<General> Transitions { get; set; }

        [JsonProperty("profiles")]
        public List<General> Profiles { get; set; }

        [JsonProperty("streaming")]
        public List<General> Streaming { get; set; }

        [JsonProperty("recording")]
        public List<General> Recording { get; set; }

        [JsonProperty("replay buffer")]
        public List<General> ReplayBuffer { get; set; }

        [JsonProperty("other")]
        public List<General> Other { get; set; }

        [JsonProperty("general")]
        public List<General> General { get; set; }

        [JsonProperty("sources")]
        public List<General> Sources { get; set; }

        [JsonProperty("studio mode")]
        public List<General> StudioMode { get; set; }
    }

    public partial class General
    {
        [JsonProperty("subheads")]
        public List<object> Subheads { get; set; }

        [JsonProperty("description")]
        public string Description { get; set; }

        [JsonProperty("return", NullValueHandling = NullValueHandling.Ignore)]
        public ParamUnion? Return { get; set; }

        [JsonProperty("api")]
        public Api Api { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("category")]
        public string Category { get; set; }

        [JsonProperty("returns", NullValueHandling = NullValueHandling.Ignore)]
        public List<ParamElement> Returns { get; set; }

        [JsonProperty("names")]
        public List<Category> Names { get; set; }

        [JsonProperty("categories")]
        public List<Category> Categories { get; set; }

        [JsonProperty("heading")]
        public Heading Heading { get; set; }

        [JsonProperty("lead")]
        public string Lead { get; set; }

        [JsonProperty("type")]
        public TypeEnum Type { get; set; }

        [JsonProperty("examples")]
        public List<object> Examples { get; set; }

        [JsonProperty("since", NullValueHandling = NullValueHandling.Ignore)]
        public Since? Since { get; set; }

        [JsonProperty("sinces", NullValueHandling = NullValueHandling.Ignore)]
        public List<Category> Sinces { get; set; }

        [JsonProperty("param", NullValueHandling = NullValueHandling.Ignore)]
        public ParamUnion? Param { get; set; }

        [JsonProperty("params", NullValueHandling = NullValueHandling.Ignore)]
        public List<ParamElement> Params { get; set; }

        [JsonProperty("deprecated", NullValueHandling = NullValueHandling.Ignore)]
        public string Deprecated { get; set; }

        [JsonProperty("deprecateds", NullValueHandling = NullValueHandling.Ignore)]
        public List<Category> Deprecateds { get; set; }
    }

    public partial class Category
    {
        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("description")]
        public string Description { get; set; }
    }

    public partial class Heading
    {
        [JsonProperty("level")]
        public long Level { get; set; }

        [JsonProperty("text")]
        public string Text { get; set; }
    }

    public partial class ParamElement
    {
        [JsonProperty("type")]
        public string Type { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("description")]
        public string Description { get; set; }
    }

    public partial class Requests
    {
        [JsonProperty("general")]
        public List<General> General { get; set; }

        [JsonProperty("profiles")]
        public List<General> Profiles { get; set; }

        [JsonProperty("recording")]
        public List<General> Recording { get; set; }

        [JsonProperty("replay buffer")]
        public List<General> ReplayBuffer { get; set; }

        [JsonProperty("scene collections")]
        public List<General> SceneCollections { get; set; }

        [JsonProperty("scene items")]
        public List<General> SceneItems { get; set; }

        [JsonProperty("scenes")]
        public List<General> Scenes { get; set; }

        [JsonProperty("sources")]
        public List<General> Sources { get; set; }

        [JsonProperty("streaming")]
        public List<General> Streaming { get; set; }

        [JsonProperty("studio mode")]
        public List<General> StudioMode { get; set; }

        [JsonProperty("transitions")]
        public List<General> Transitions { get; set; }
    }

    public enum Api { Events, Requests };

    public enum Since { The03, The400, The410, The420, The430, The4XX, Unreleased };

    public enum TypeEnum { Class };

    public partial struct ParamUnion
    {
        public string String;
        public List<string> StringArray;

        public static implicit operator ParamUnion(string String) => new ParamUnion { String = String };
        public static implicit operator ParamUnion(List<string> StringArray) => new ParamUnion { StringArray = StringArray };
    }

    public partial class Commands
    {
        public static Commands FromJson(string json) => JsonConvert.DeserializeObject<Commands>(json, OBS.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this Commands self) => JsonConvert.SerializeObject(self, OBS.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                ApiConverter.Singleton,
                ParamUnionConverter.Singleton,
                SinceConverter.Singleton,
                TypeEnumConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class ApiConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Api) || t == typeof(Api?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "events":
                    return Api.Events;
                case "requests":
                    return Api.Requests;
            }
            throw new Exception("Cannot unmarshal type Api");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Api)untypedValue;
            switch (value)
            {
                case Api.Events:
                    serializer.Serialize(writer, "events");
                    return;
                case Api.Requests:
                    serializer.Serialize(writer, "requests");
                    return;
            }
            throw new Exception("Cannot marshal type Api");
        }

        public static readonly ApiConverter Singleton = new ApiConverter();
    }

    internal class ParamUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ParamUnion) || t == typeof(ParamUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new ParamUnion { String = stringValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<string>>(reader);
                    return new ParamUnion { StringArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type ParamUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (ParamUnion)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.StringArray != null)
            {
                serializer.Serialize(writer, value.StringArray);
                return;
            }
            throw new Exception("Cannot marshal type ParamUnion");
        }

        public static readonly ParamUnionConverter Singleton = new ParamUnionConverter();
    }

    internal class SinceConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Since) || t == typeof(Since?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "0.3":
                    return Since.The03;
                case "4.0.0":
                    return Since.The400;
                case "4.1.0":
                    return Since.The410;
                case "4.2.0":
                    return Since.The420;
                case "4.3.0":
                    return Since.The430;
                case "4.x.x":
                    return Since.The4XX;
                case "unreleased":
                    return Since.Unreleased;
            }
            throw new Exception("Cannot unmarshal type Since");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Since)untypedValue;
            switch (value)
            {
                case Since.The03:
                    serializer.Serialize(writer, "0.3");
                    return;
                case Since.The400:
                    serializer.Serialize(writer, "4.0.0");
                    return;
                case Since.The410:
                    serializer.Serialize(writer, "4.1.0");
                    return;
                case Since.The420:
                    serializer.Serialize(writer, "4.2.0");
                    return;
                case Since.The430:
                    serializer.Serialize(writer, "4.3.0");
                    return;
                case Since.The4XX:
                    serializer.Serialize(writer, "4.x.x");
                    return;
                case Since.Unreleased:
                    serializer.Serialize(writer, "unreleased");
                    return;
            }
            throw new Exception("Cannot marshal type Since");
        }

        public static readonly SinceConverter Singleton = new SinceConverter();
    }

    internal class TypeEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TypeEnum) || t == typeof(TypeEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "class")
            {
                return TypeEnum.Class;
            }
            throw new Exception("Cannot unmarshal type TypeEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TypeEnum)untypedValue;
            if (value == TypeEnum.Class)
            {
                serializer.Serialize(writer, "class");
                return;
            }
            throw new Exception("Cannot marshal type TypeEnum");
        }

        public static readonly TypeEnumConverter Singleton = new TypeEnumConverter();
    }
}
